---
title: "Lista 2 - Econometria 2"
author: "Augusto Floriano, Danyel Lima, Fernando Soares e Gustavo Darmont"
date: "2025-09-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.align="center")

if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, knitr, zoo, lubridate)
```

# Questão 1: Asset Pricing

## (a) 

### Carregando e Tratando os Dados

```{r DADOS, include=FALSE}
## DADOS DE FAMA-FRENCH:

# Importação dos Dados
ff_raw <- read_csv("Developed_25_Portfolios_ME_BE-ME.csv", skip = 20)

# Limpeza e Tratamento Mensal
ff_monthly <- ff_raw %>%
  rename(Date = `...1`) %>%
  filter(!is.na(Date), !str_detect(Date, "Copyright")) %>%
  mutate(Date = ymd(paste0(Date, "01"))) %>%
  mutate(across(-Date, as.numeric))

# Conversão para Trimestral (compondo os retornos)
ff_quarterly <- ff_monthly %>%
  mutate(YearQuarter = as.yearqtr(Date)) %>%
  group_by(YearQuarter) %>%
  summarise(across(
    .cols = -Date,
    .fns = ~ (prod(1 + .x / 100, na.rm = TRUE) - 1) * 100
  )) %>%
  ungroup()


## DADOS DE CONSUMO:

# Importação dos Dados de Consumo Real de Não-Duráveis
bea_raw <- read_csv("Table 2.3.6. Real Personal Consumption Expenditures by Major Type of Product, Chained Dollars.csv", skip = 3)

# Limpeza e Transformação
nondurables_quarterly <- bea_raw %>%
  filter(Line == 8) %>%
  select(contains("Q")) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Quarter",
    values_to = "Nondurables_Real"
  ) %>%
  mutate(
    YearQuarter = as.yearqtr(Quarter, format = "%YQ%q"),
    Nondurables_Real = as.numeric(Nondurables_Real)
  )


# Cálculo do Crescimento do Consumo
# O cálculo abaixo é do crescimento do consumo agregado real. É preciso de uma série de POPULAÇÃO do BEA para fazer o cálculo per-capita
# O código seria:
# 1. Carregar a série de população trimestral (ex: `pop_data`).
# 2. Fazer um left_join: `nondurables_quarterly <- nondurables_quarterly %>% left_join(pop_data, by = "YearQuarter")`
# 3. Criar a variável per capita: `mutate(Nondurables_Real_PC = Nondurables_Real / Population)`
# 4. Calcular o crescimento com base na nova variável.

# Por enquanto, calcularemos o crescimento com a série agregada.
consumption_growth <- nondurables_quarterly %>%
  arrange(YearQuarter) %>%
  mutate(
    # consumption_growth = log(C_t) - log(C_{t-1})
    consumption_growth = log(Nondurables_Real) - lag(log(Nondurables_Real))
  )


## JUNÇÃO DAS BASES E PREPARAÇÃO FINAL
final_data <- ff_quarterly %>%
  left_join(consumption_growth, by = "YearQuarter") %>%
  # A lista menciona 2025Q11, provavelmente um erro de digitação para 2025Q1. Ajuste se necessário.
  filter(YearQuarter >= as.yearqtr("1947 Q1") & YearQuarter <= as.yearqtr("2025 Q1"))

# 3.2. Observação sobre o Equity Premium
# Para os itens seguintes, você precisará calcular o "equity premium" (excesso de retorno).
# Para isso, é necessário a taxa de juro livre de risco (Risk-Free Rate, RF).
# Você pode baixar o arquivo "Fama/French 3 Factors" do site do Kenneth French,
# que contém a coluna RF. O processo seria:
# 1. Carregar o arquivo dos fatores.
# 2. Converter a coluna RF mensal para trimestral (compondo-a como fizemos com os retornos).
# 3. Fazer um `left_join` para adicionar a RF trimestral à base `final_data`.
# 4. Subtrair a RF de cada uma das 25 colunas de portfólio.
# Exemplo: `final_data_premium <- final_data %>% mutate(across(SMALL LoBM:BIG HiBM, ~ .x - RF_trimestral))`

#-----------------------------------------------------------------------
# PARTE 4: VISUALIZAÇÃO DOS DADOS FINAIS
#-----------------------------------------------------------------------
# Ao executar este chunk, o RStudio mostrará o início e o fim da sua base de dados final.
cat("Base de dados final pronta para análise!\n\n")
cat("Dimensões:", dim(final_data), "\n")
cat("Período:", as.character(min(final_data$YearQuarter)), "a", as.character(max(final_data$YearQuarter)), "\n\n")

cat("Cabeçalho da base de dados:\n")
head(final_data)
```

## (b)


# Questão 2: Modelo SARIMA

## a)

```{r}
library(dplyr);library(ggplot2);library(forecast);library(tseries);library(urca);library(plotly)
ipca<-readRDS("C:/Users/danye/OneDrive/Documentos/ipca_precos12_2000_2025.rds");s<-ts(ipca$value,start=c(2000,1),frequency=12)
summary(ipca$value);c(mean=mean(ipca$value),sd=sd(ipca$value),min=min(ipca$value),max=max(ipca$value))
ggplotly(autoplot(s)+theme_classic()+ggtitle("IPCA - Índice (2000-2025)"))%>%layout(plot_bgcolor="white",paper_bgcolor="white",yaxis=list(rangemode="tozero"))
ggplotly(autoplot(log(s))+theme_classic()+ggtitle("Log do IPCA"))%>%layout(plot_bgcolor="white",paper_bgcolor="white",yaxis=list(rangemode="tozero"))
ggplotly(autoplot(diff(log(s)))+theme_classic()+ggtitle("Δlog(IPCA)"))%>%layout(plot_bgcolor="white",paper_bgcolor="white",yaxis=list(rangemode="tozero"))
```

Pode-se observar uma notável tendência de crescimento do IPCA tanto em nível quanto em log, enquanto o comportamento dos dados em diferença do log apresentam um comportamento mais oscilatório, sem tendência clara de crescimento e se aproximando um pouco mais de um ruído branco.

```{r}
adf.test(s);pp.test(s)
```

Pode-se observar que os testes não rejeitam a hipótese nula de raiz unitária, dado o elevado p-valor dos testes, o que indica uma iminente tendência estocástica e não-estacionariedade, conforme indicado pelos gráficos.

```{r}
adf.test(log(s));pp.test(log(s))
```

Assim como em nível, em log se observa um p-valor elevado, com os testes não rejeitando a hipótese nula de raiz unitária, indicando novamente tendência estocástica e não-estacionariedade

```{r}
adf.test(diff(log(s)));pp.test(diff(log(s)))
```

Para os dados em diferença do log, observa-se um p-valor consideravelmente menor, rejeitando a hipótese nula de raiz unitária e indicando estacionariedade.

```{r}
d<-diff(log(s));a<-acf(d,plot=FALSE,na.action=na.pass);p<-pacf(d,plot=FALSE,na.action=na.pass);ci<-qnorm(0.975)/sqrt(a$n.used)
xa<-as.numeric(a$lag)*12;ya<-as.numeric(a$acf);xp<-as.numeric(p$lag)*12;yp<-as.numeric(p$acf)
plot_ly(x=xa,y=ya,type="bar")%>%layout(title="ACF Δlog(IPCA)",plot_bgcolor="white",paper_bgcolor="white",xaxis=list(title="Defasagem (meses)"),yaxis=list(title="Correlação",rangemode="tozero"),shapes=list(list(type="line",xref="x",yref="y",x0=min(xa),x1=max(xa),y0=ci,y1=ci),list(type="line",xref="x",yref="y",x0=min(xa),x1=max(xa),y0=-ci,y1=-ci)))
plot_ly(x=xp,y=yp,type="bar")%>%layout(title="PACF Δlog(IPCA)",plot_bgcolor="white",paper_bgcolor="white",xaxis=list(title="Defasagem (meses)"),yaxis=list(title="Correlação",rangemode="tozero"),shapes=list(list(type="line",xref="x",yref="y",x0=min(xp),x1=max(xp),y0=ci,y1=ci),list(type="line",xref="x",yref="y",x0=min(xp),x1=max(xp),y0=-ci,y1=-ci)))
```

Enquanto na PACF não se observa nenhum lag significativo, com todos os lags após o lag nulo se mantendo dentro do intervalo de confiança, pode-se assumir que as partes de média móvel sejam 0 tanto no aspecto não-sazonal quanto no sazonal, com possivelmente $q=Q=0$.

Contudo, analisando a ACF, é possível observar um decaimento gradual após o lag 0 e além disso um comportamento de crescimento após um ano, indicando um possível fator AR tanto sazonal quanto não-sazonal, indicando possivelmente que $p=P=1$.

Dessa forma, o modelo que tende a ser o mais adequado para o IPCA é o $SARIMA(1,1,0)(1,0,0)_{12}$.

## b)

```{r}
library(forecast);library(plotly)
y<-log(s)
fit1<-Arima(y,order=c(1,1,0),seasonal=list(order=c(1,0,0),period=12),include.drift=FALSE,method="ML")
fit2<-Arima(y,order=c(1,1,0),seasonal=list(order=c(0,0,1),period=12),include.drift=FALSE,method="ML")
summary(fit1);summary(fit2)
```

Estimados os dois modelos, podemos observar valores muito próximos nos testes de AIC e BIC, mas o modelo com termo AR sazonal apresenta um valor substancialmente menor em ambos os testes, sendo esse o modelo mais indicado com base nos dois testes.

```{r}
plres<-function(f,t){
  r<-na.omit(residuals(f));ix<-seq_along(r)
  a<-acf(r,plot=FALSE);p<-pacf(r,plot=FALSE);ci<-qnorm(0.975)/sqrt(a$n.used)
  xa<-as.numeric(a$lag)*12;ya<-as.numeric(a$acf);xp<-as.numeric(p$lag)*12;yp<-as.numeric(p$acf)
  rt<-plot_ly(x=ix,y=as.numeric(r),type="scatter",mode="lines")%>%layout(title=paste0("Resíduos - ",t),plot_bgcolor="white",paper_bgcolor="white",xaxis=list(title="Índice temporal"),yaxis=list(title="Resíduo",rangemode="tozero"))
  ac<-plot_ly(x=xa,y=ya,type="bar")%>%layout(title=paste0("ACF dos resíduos - ",t),plot_bgcolor="white",paper_bgcolor="white",xaxis=list(title="Defasagem (meses)"),yaxis=list(title="Correlação",rangemode="tozero"),shapes=list(list(type="line",xref="x",yref="y",x0=min(xa),x1=max(xa),y0=ci,y1=ci),list(type="line",xref="x",yref="y",x0=min(xa),x1=max(xa),y0=-ci,y1=-ci)))
  pc<-plot_ly(x=xp,y=yp,type="bar")%>%layout(title=paste0("PACF dos resíduos - ",t),plot_bgcolor="white",paper_bgcolor="white",xaxis=list(title="Defasagem (meses)"),yaxis=list(title="Correlação",rangemode="tozero"),shapes=list(list(type="line",xref="x",yref="y",x0=min(xp),x1=max(xp),y0=ci,y1=ci),list(type="line",xref="x",yref="y",x0=min(xp),x1=max(xp),y0=-ci,y1=-ci)))
  list(rt=rt,ac=ac,pc=pc)
}
g1<-plres(fit1,"SARIMA(1,1,0)(1,0,0)[12]")
g2<-plres(fit2,"SARIMA(1,1,0)(0,0,1)[12]")
g1$rt;g2$rt
g1$ac;g2$ac
g1$pc;g2$pc
```

Dado que os dois modelos tem coeficientes próximos, é esperado um desempenho similar dos gráficos de resíduos, algo que de fato ocorre, com ambos aproximando-se de um ruído branco. Em ambos os modelos se observa um decaimento após o lag 0 com os lags $1$ e $2$ sendo negativos e fora do intervalo de confiança por uma diferença mínima além de um lag $15$ significativo, o que poderia talvez indicar a necessidade de estimação de mais parâmetros para um ajuste mais fino, mas que perderia em parcimônia com a estimação de novos parâmetros. O mesmo vale para os valores dos lags $1$ e $2$ fora do intervalo de confiança da PACF em ambos os modelos.

```{r}
lb<-function(f,k)c(LB24=Box.test(residuals(f),type="Ljung-Box",lag=24,fitdf=k)$p.value,
                   LB36=Box.test(residuals(f),type="Ljung-Box",lag=36,fitdf=k)$p.value)
rbind("(1,1,0)(1,0,0)[12]"=lb(fit1,2),
      "(1,1,0)(0,0,1)[12]"=lb(fit2,2))
```

Os testes de Ljung-box para os lags $24$ e $36$ apresentaram p-valores superiores a $5\%$, o que indica ausênsia de correlação residual, e então que os modelos estão capturando adequadamente a estrutura temporal da série, sem restar um padrão sistemático claro dos erros aparentemente.
